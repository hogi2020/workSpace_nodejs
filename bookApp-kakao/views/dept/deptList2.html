<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handlebars - 실습</title>

    <!-- Handlebars 라이브러리 추가 -->
    <!-- min은 라이브러리의 소형 버전으로 효율적인 처리가 가능함 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.7/handlebars.min.js"></script>
</head>
<body>

    <!-- 
        화면과 데이터가 만나는 부분을 어떻게 처리하지?
        데이터는 영속성을 보장받기 위해 오라클과 같은 서버제품 사용함. - 눈에 안보이는 부분 - 뒤에서 - 몰래
        화면과 로직을 분리하자 - MVC 패턴에 대한 시작
        리액트와 스프링을 연계하기
        우리의 목표는 for문을 태그 중간에 절대로 쓰지 않겠다. - 다짐
        Handlebars를 통해서 이루자.
    -->

    <script>
        // 부서집합 데이터셋 추가
        // 배열 앞에 붙은 라벨이 each문 사용됨.
        const data = {
            depts: [
                {deptno:10, dname:"개발1팀", loc:"서울"},
                {deptno:20, dname:"운영팀", loc:"제주"},
                {deptno:30, dname:"품질관리팀", loc:"세종"}
            ]
        }
    </script>

    <!-- li 태그의 수를 우리가 정할 수 없다. 데이터셋의 수를 봐야 결정이 가능함. -->
    <script id="dept-template" type="text/x-handlebars-template">
        <ul>
            {{#each depts}}
            <li>{{deptno}}, {{dname}}, {{loc}}</li>
            {{/each}}
        </ul>
    </script>
    <!-- 데이터를 바인딩해줄 컨테이너를 -->
    <div id="root"></div>
    <script>
        // 템플릿 가져오기 - script 태그 안에 들어있는 HTML 태그들
        const source = document.querySelector("#dept-template").innerHTML
        // 템플릿을 컴파일 (compile)
        const template = Handlebars.compile(source)
        const html = template(data)
        // 결과를 출력하기
        document.querySelector("#root").innerHTML = html
    </script>
</body>
</html>